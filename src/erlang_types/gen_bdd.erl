-module(gen_bdd).

% A generic BDD parameterized over both the 'nodes and 'leafs: BDD<Element, Terminal>
%
% The BDD is parameterized over the implementation module variables:
% $Terminal implements type and eq
% $Element implements eq
%
% 'Element' and 'Terminal' are reserved variable names
% This module assumes they implement callbacks of the respective modules
%
% A BDD represents a DNF of 'nodes intersected with a terminal type generated by a 'leaf.
% A leaf itself can be a DNF (e.g. for functions or tuples), or a compact representation for a basic type (e.g. atoms).
%
% Used to represent a DNF of variables where each co-clause is intersected with a DNF of a nested kind
% and a DNF of variables with compact leaf nodes for intervals, specials, and atoms.

%%-type terminal() :: any(). % :: Terminal:type()
%%-type element() :: any().  % :: Element:type()
%%-type bdd() :: 0 | {terminal, terminal()} | {node, element(), bdd(), bdd()}.

%% % implements type behavior indirectly parameterized over a type
-export([terminal/2, element/2, empty/1, any/1, union/3, intersect/3, negate/2, diff/3, is_empty/2, is_any/2]).

%% % implements eq behavior indirectly parameterized over a type
-export([equal/3, compare/3, is_empty_union/2, substitute/5]).

-export([dnf/3]).

% ==
% basic interface (parameterized)
% ==
equal(Gen = {_, Element}, {node, E1, A1, B1}, {node, E2, A2, B2}) ->
    Element:equal(E1, E2)
    andalso equal(Gen, A1, A2)
    andalso equal(Gen, B1, B2);
equal({Terminal, _}, {terminal, T1}, {terminal, T2}) ->
  Terminal:equal(T1, T2);
equal(_, _, _) ->
  false.

compare({Terminal, _}, {terminal, T1}, {terminal, T2}) -> Terminal:compare(T1, T2);
compare(_, {terminal, _}, {node, _, _, _}) -> +1;
compare(_, {node, _, _, _}, {terminal, _}) -> -1;
compare(Gen = {_, Element}, {node, E1, A1, B1}, {node, E2, A2, B2}) ->
  case Element:compare(E1, E2) of
    0 ->
      case compare(Gen, A1, A2) of
        0 -> compare(Gen, B1, B2);
        Res -> Res
      end;
    Res -> Res
  end.

% ==
% type interface
% ==
empty({Terminal, _}) -> {terminal, Terminal:empty()}.
any({Terminal, _}) -> {terminal, Terminal:any()}.

element(I = {_Terminal, _Element}, Atom) ->
  s(I, {node, Atom, any(I), empty(I)}).

terminal(I = {_Terminal, _}, Ty) ->
  terminal_of(I, Ty).


union(I = {Terminal, Element}, A, B) ->
  case is_empty(I, A) of
    true -> B;
    _ ->
      case is_empty(I, B) of
        true -> A;
        _ ->
          case is_any(I, A) orelse is_any(I, B) of
            true -> any(I);
            _ ->
              case {A, B} of
                {{terminal, X}, {terminal, Y}} -> terminal_of(I, Terminal:union(X, Y));
                {BDD1 = {node, E, A1, B1}, BDD2 = {node, E2, A2, B2}} ->
                  case Element:compare(E, E2) of
                    -1 ->
                      s(I,{node, E, s(I,union(I, A1, BDD2)), s(I,union(I, B1, BDD2))});
                    +0 ->
                      s(I,{node, E, s(I,union(I, A1, A2)), s(I,union(I, B1, B2))});
                    +1 ->
                      s(I,{node, E2, s(I,union(I, A2, BDD1)), s(I,union(I, B2, BDD1))})
                  end;
                {BDD1 = {terminal, _X}, _BDD2 = {node, E2, A2, B2}} ->
                  s(I, {node, E2, s(I, union(I, A2, BDD1)), s(I, union(I, B2, BDD1))});
                {_BDD1 = {node, E1, A1, B1}, BDD2 = {terminal, _X}} ->
                  s(I, {node, E1, s(I, union(I, A1, BDD2)), s(I, union(I, B1, BDD2))})
              end
          end
      end
  end.

negate(I = {Terminal, _}, {terminal, A}) ->
  s(I, {terminal, Terminal:negate(A)});
negate(I, {node, E, B1, B2}) -> s(I, {node, E, s(I, negate(I, B1)), s(I, negate(I, B2))}).


diff(I, A, B) -> intersect(I, A, negate(I, B)).
intersect(I, A, B) -> negate(I, union(I, negate(I, A), negate(I, B))).


is_any({Terminal, _}, {terminal, Ty}) -> Terminal:equal(Ty, Terminal:any());
is_any(_, _) -> false.

% convert empty terminal node into empty BDD node
terminal_of({Terminal, _}, Ty) ->
  case Terminal:equal(Ty, Terminal:empty()) of
    true -> {terminal, Terminal:empty()};
    _ ->
      case Terminal:equal(Ty, Terminal:any()) of
        true -> {terminal, Terminal:any()};
        _ ->
          {terminal, Ty}
      end
  end.


s(_G, {node, _, B, B}) -> B;
s(_G, X) -> X.

is_empty({Terminal, _}, {terminal, Ty}) -> Terminal:equal(Ty, Terminal:empty());
is_empty(_, _) -> false.

is_empty_union(F1, F2) ->
  F1() andalso F2().

dnf(I, Bdd, {ProcessCoclause, CombineResults}) ->
  do_dnf(I, Bdd, {ProcessCoclause, CombineResults}, _Pos = [], _Neg = []).

do_dnf(I, {node, Element, Left, Right}, F = {_Process, Combine}, Pos, Neg) ->
  F1 = fun() -> do_dnf(I, Left, F, [Element | Pos], Neg) end,
  F2 = fun() -> do_dnf(I, Right, F, Pos, [Element | Neg]) end,
  Combine(F1, F2);
do_dnf(_, {terminal, Terminal}, {Proc, _Comb}, Pos, Neg) ->
  Proc(Pos, Neg, Terminal).

substitute(I, MkTy, Bdd, Map, Memo) ->
  gen_bdd:dnf(I, Bdd, {
    fun(P,N,T) -> substitute_coclause(I,MkTy,P,N,T, Map, Memo) end,
    fun(F1, F2) -> union(I, F1(), F2()) end
  }).

substitute_coclause(I,_, _P, _N, 0, _Map, _Memo) -> empty(I);
substitute_coclause(I = {Terminal, Element},MkTy,P, N, T, Map, Memo) ->
  %Terminal :: dnf_ty_list, Element :: ty_variable
      %Terminal :: bdd_bool, Element :: ty_list

  % Terminal:substitute :: Terminal -> Terminal
  % Terminal:substitute :: dnf_ty_list -> dnf_ty_list
    % Terminal:substitute :: bdd_bool -> bdd_bool
  % currently MkTy :: ty_rec -> dnf_var_ty_list
%%  io:format(user, "Using substitution of ~p~n", [Terminal]),
  NewTerminalBDD = terminal_of(I, Terminal:substitute(MkTy, T, Map, Memo)),
  % NewTerminalBDD :: BDD

%%  io:format(user, "We are in: ~p~n",[{terminal_type, Terminal, element_Type, Element}]),
%%  io:format(user, "We have a map: ~p~n",[Map]),
%%  io:format(user, "Pos (Elements): ~p~n",[P]),
%%  io:format(user, "Neg (Elements): ~p~n",[N]),
%%  io:format(user, "Terminal: ~p~n",[T]),
%%  io:format(user, "Subst. BDD: ~p~n",[NewTerminalBDD]),

  % Element substitute :: Element -> Element
  % Element substitute :: ty_variable -> ty_rec --> dnf_var_ty_list
      % Element substitute :: ty_list -> ty_list
  PosL = lists:map(fun(L) ->
    case Element of
      ty_variable ->
%%        io:format(user, "Doing Pos VARIABLE subst: ~p~n",[L]),
        Res = Element:substitute(MkTy, L, Map, Memo),
%%        io:format(user, "Doing Pos VARIABLE subst: ~p -> ~p~n",[L, Res]),
        Res;
      _ ->
%%        io:format(user, "Doing Pos subst: ~p~n",[L]),
        E = Element:substitute(MkTy, L, Map, Memo),
%%        io:format(user, "E: ~p~n",[E]),
        EBdd = gen_bdd:element(I, E),
%%        io:format(user, "as BDD E: ~p~n",[EBdd]),
        EBdd
    end
                   end, P),

  NegL = lists:map(fun(L) ->
    % FIXME how to not need a special case for variables?
    case Element of
      ty_variable ->
        Res = negate(I, Element:substitute(MkTy, L, Map, Memo)),
%%        io:format(user, "Doing Neg VARIABLE subst: ~p -> ~p~n",[L, Res]),
        Res
      ;
      _ ->
%%        io:format(user, "Doing Neg subst: ~p~n",[L]),
        negate(I, gen_bdd:element(I, Element:substitute(MkTy, L, Map, Memo)))
    end
                   end, N),

  Res = lists:foldl(fun(E,Ac) ->
    intersect(I, E, Ac)
                    end, any(I), PosL ++ NegL),
  X = intersect(I, NewTerminalBDD, Res),
%%  io:format(user, "Final ~p :: ~p~n",[I, X]),
  X.